# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file './pythonGUI/Scanbak.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import sys
import urllib.request
import queue
import threading

import socket

from datetime import datetime
# 线程池
from multiprocessing.dummy import Pool as ThreadPool

from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_Scanbak(QtWidgets.QMainWindow):
     # 为了使类继承父类中的内容
    def __init__(self):
        super(Ui_Scanbak,self).__init__()
        self.setupUi(self)
        self.retranslateUi(self)
    ###########
    def setupUi(self, Scanbak):
        Scanbak.setObjectName("Scanbak")
        Scanbak.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(Scanbak)
        self.centralwidget.setObjectName("centralwidget")
        self.lineEdit_in = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_in.setGeometry(QtCore.QRect(21, 99, 761, 24))
        self.lineEdit_in.setObjectName("lineEdit_in")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(270, 40, 400, 71))
        self.label.setObjectName("label")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(200, 420, 93, 28))
        self.pushButton.setObjectName("pushButton")
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.setGeometry(QtCore.QRect(450, 420, 93, 28))
        self.pushButton_2.setObjectName("pushButton")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(360, 140, 41, 20))
        self.label_2.setObjectName("label_2")
        self.textEdit = QtWidgets.QTextEdit(self.centralwidget)
        self.textEdit.setGeometry(QtCore.QRect(23, 170, 761, 201))
        self.textEdit.setObjectName("textEdit")
        Scanbak.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(Scanbak)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))
        self.menubar.setObjectName("menubar")
        Scanbak.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(Scanbak)
        self.statusbar.setObjectName("statusbar")
        Scanbak.setStatusBar(self.statusbar)

        self.pushButton.clicked.connect(self.scanbak)
        self.pushButton_2.clicked.connect(self.port)
        
        self.retranslateUi(Scanbak)
        QtCore.QMetaObject.connectSlotsByName(Scanbak)

    def retranslateUi(self, Scanbak):
        _translate = QtCore.QCoreApplication.translate
        Scanbak.setWindowTitle(_translate("Scanbak", "MainWindow"))
        self.label.setText(_translate("Scanbak", "请输入存有url网址的txt文件地址/请输入IP"))
        self.pushButton.setText(_translate("Scanbak", "url网址检测"))
        self.pushButton_2.setText(_translate("Scanbak","IP扫描"))
        self.label_2.setText(_translate("Scanbak", "输出"))
        self.textEdit.setText("1.url网址检测：扫描敏感文件目录是否存在，以及当文件存在时，读出文件的大小。\n\n\n2.IP扫描：扫描服务器的端口开启情况。")

    # 功能实现    
    def bytes2human(self,n):
        """
        >>> bytes2human(10000)
        9K
        >>> bytes2human(100001221)
        95M
        """
        symbols = ('K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
        prefix     = {}
        for i, s in enumerate(symbols):
            prefix[s] = 1 << (i+1)*10
        
        for s in reversed(symbols):
            if n >= prefix[s]:
                value = int(float(n)/prefix[s])
                return '%s%s' % (value, s)
        return '%sB' % n









    def gethtml(self,url,bak):
        
        try:
            urlbak=url+bak
            self.textEdit.append(urlbak)# print (urlbak)
            req=urllib.request.urlopen(urlbak,timeout=10)
            if req.code==200:
                meta = req.info()
                file_size = int(meta.getheaders("Content-Length")[0])
                m=self.bytes2human(file_size)
                content_type = meta.getheaders('Content-Type')[0].split(';')[0]
                if file_size == 0:
                    return False
                if 'html' in content_type:
                    return False
                else:
                    self.textEdit.append('%s ---- %s ---- %s ' % (urlbak,m,content_type))#print  ('%s ---- %s ---- %s ' % (urlbak,m,content_type))
                    return '%s ---- %s ---- %s ' % (urlbak,m,content_type)
            else:
                return False
        except:
            return False
        


    def writefile(self,fileName,c):
        f=open(fileName,"a")
        f.write(c+"\n")
        f.close()






    q=queue.Queue()





    def scanner(self,url):
        for i in self.bekadd(url):
            c = self.gethtml(url,i)
            if c!=False:
                self.writefile("bak.txt",c)






    def worker(self):
        while not self.q.empty():
            url=self.q.get()
            self.scanner(url)
            self.task_done()



    def bekadd(self,url):
        listbak=['/1.zip','/1.rar','/web.rar','/web.zip','/www.rar','/www.zip','/wwwroot.rar','/wwwroot.zip','/backup.rar','/backup.zip','/database.rar','/database.zip','/databak.rar','/databak.zip','/databackup.rar','/databackup.zip','/databack.zip','/sql.rar','/sql.zip']
        wwwurl = url[url.find("http://")+7:].rstrip("/")
        urldomain =url[url.rfind('.', 0, url.rfind('.')) + 1:].rstrip("/")
        urlcenter=urldomain[0:urldomain.rfind('.')].rstrip("/")
        wwwurl="/"+wwwurl
        urldomain="/"+urldomain
        urlcenter="/"+urlcenter
        listbak.append(wwwurl+".rar")
        listbak.append(wwwurl+".zip")
        listbak.append(urldomain+".rar")
        listbak.append(urldomain+".zip")
        listbak.append(urlcenter+".rar")
        listbak.append(urlcenter+".zip")
        return listbak




    # t = threading.Thread()
    # 启动函数
    def scanbak(self):
        self.textEdit.setPlainText("")
        lines = open(self.lineEdit_in.text(), "r")
        for line in lines:
            line=line.rstrip()
            self.q.put(line)
        
        for i in range(100): 
            t = threading.Thread(target=self.worker)
            t.start()
            
    # t.join()

    ################# 功能函数
    # 目标IP
    # remote_server_ip = "47.99.142.216"
    # 目标ip启用端口
    ports = []
    # 设置连接超时为0.5s，在校园网中使用时可以适当延长时间
    socket.setdefaulttimeout(0.5)

    # 端口扫描
    def scan_port(self,port):
        try:
            # 创建套接字
            s = socket.socket()
            # connect()函数的扩展版本,出错时返回出错码,而不是抛出异常
            # connect_ex（）和connect（）一样都需要传入，ip和port
            # 连接成功时返回 0 ，连接失败时候返回编码，例如：10061
            res = s.connect_ex((self.textEdit.toPlainText(), port))

            if res == 0:  # 如果端口开启 发送 hello 获取banner

                self.textEdit.append(f'Port {port}: OPEN')#print(f'Port {port}: OPEN')

            s.close()

        except Exception as e:
            self.textEdit.append(str(e.message))#print(str(e.message))


    #   启动函数
    def port(self):
        self.textEdit.setPlainText("")
        for i in range(1, 65535):
            self.ports.append(i)

        # 显示扫描时间
        t1 = datetime.now()
        # 设置线程池
        pool = ThreadPool(processes=1000)
        # map() 会根据提供的函数对指定序列做映射。
        results = pool.map(self.scan_port, self.ports)

        pool.close()

        self.textEdit.append('Multiprocess Scanning Completed in  '+ (str) (datetime.now() - t1))

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Scanbak = QtWidgets.QMainWindow()
    ui = Ui_Scanbak()
    ui.setupUi(Scanbak)
    Scanbak.show()
    sys.exit(app.exec_())
